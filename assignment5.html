<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Spirograph</title>
<style>
  body { font-family: Arial, sans-serif; }
  canvas { border: 1px solid black; display: block; margin: 10px 0; }
  label { display: inline-block; width: 50px; }
  input { width: 60px; }
</style>
</head>
<body>

<h2>Spirograph Generator</h2>

<div>
  <label>R:</label><input type="number" id="R" value="100" min="10" max="200" />
  <label>r:</label><input type="number" id="r" value="30" min="5" max="100" />
  <label>O:</label><input type="number" id="O" value="50" min="0" max="100" />
  <button id="startBtn">Start Drawing</button>
</div>

<canvas id="canvas" width="600" height="600"></canvas>

<script>
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const startBtn = document.getElementById('startBtn');

  // Clear and set origin to center
  function resetCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.translate(canvas.width / 2, canvas.height / 2);
    ctx.strokeStyle = 'blue';
    ctx.lineWidth = 1;
    ctx.beginPath();
  }

  // We'll need to remove transform each time before reset or save/restore
  function clearAndReset() {
    ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
    resetCanvas();
  }

  // Validate inputs and parse values
  function getParameters() {
    const R = parseFloat(document.getElementById('R').value);
    const r = parseFloat(document.getElementById('r').value);
    const O = parseFloat(document.getElementById('O').value);

    if (
      isNaN(R) || R < 10 || R > 200 ||
      isNaN(r) || r < 5 || r > 100 ||
      isNaN(O) || O < 0 || O > 100
    ) {
      alert('Please enter valid numbers:\nR: 10-200\nr: 5-100\nO: 0-100');
      return null;
    }
    return { R, r, O };
  }

  // Main drawing function
  function drawSpirograph(R, r, O) {
    clearAndReset();

    let t = 0;
    const maxT = Math.PI * 2 * r / gcd(R, r); // Approximate one full cycle
    let prevX, prevY;

    function drawStep() {
      // Equation for x, y based on t
      const x = (R + r) * Math.cos(t) - (r + O) * Math.cos(((R + r) / r) * t);
      const y = (R + r) * Math.sin(t) - (r + O) * Math.sin(((R + r) / r) * t);

      if (t === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
        ctx.stroke();
      }

      prevX = x;
      prevY = y;

      t += 0.01;

      if (t <= maxT) {
        requestAnimationFrame(drawStep);
      }
    }

    drawStep();
  }

  // Greatest Common Divisor (needed to estimate cycle length)
  function gcd(a, b) {
    if (!b) return a;
    return gcd(b, a % b);
  }

  startBtn.addEventListener('click', () => {
    const params = getParameters();
    if (!params) return;
    drawSpirograph(params.R, params.r, params.O);
  });

  // Initialize canvas with origin at center
  resetCanvas();

</script>

</body>
</html>
